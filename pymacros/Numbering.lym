<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya
import math

# PCell template
# This macro template provides the framework for a PCell library

# It is recommended to put PCell code into namespaces.
# TODO: change the module name

# The PCell declaration
# Each PCell must provide a declaration. It is recommended to use the PCell name as the class name.
# TODO: change the class name
class Numbering(pya.PCellDeclarationHelper):

  def __init__(self):

    # Important: initialize the super class
    super(Numbering, self).__init__()

    # declare the parameters
    # i.e. self.param("l", self.TypeLayer, "Layer", default = pya.LayerInfo(1, 0))
    #      self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    # declare the parameters
    self.param("layers", self.TypeList, "layers", default =[0])
    self.param("hierarchy_levels", self.TypeList, "hierarchy levels to explore", default =[0])
    self.param("explode", self.TypeBoolean, "break down arrays", default =True)
    self.param("mark_less", self.TypeBoolean, "mark all cells with hierarchy level less than spec", default =False)
    self.param("text_line_width", self.TypeDouble, "text_line_width", default =3)
    self.param("text_shift_x", self.TypeDouble, "shift text beyond cell x", default =0)
    self.param("text_shift_y", self.TypeDouble, "shift text beyond cell y", default =0)
    self.param("left_x", self.TypeDouble, "mark cells from x", default =-75000)
    self.param("bot_y", self.TypeDouble, "mark cells from y", default =-75000)
    self.param("right_x", self.TypeDouble, "mark cells to x", default =75000)
    self.param("top_y", self.TypeDouble, "mark cells to y", default =75000)
    self.param("forbidden", self.TypeList, "ignore cells with strings in name", default =["text","contact","numbering", "die", "alig", "xxx", "naming"])
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Numbering"
  
  def coerce_parameters_impl(self):
    pass
    # TODO: use x to access parameter x and set_x to modify it's value 
  def produce_impl(self):
    # TODO: produce the cell content 
    # i.e. self.cell().shapes(self.l_layer).insert(pya.Polygon(...))
    def forbbiden_check(inst):
      fb_check = False
      for fb in self.forbidden:
        fb_check  = fb_check or fb.casefold() in layout.cell(inst.cell_index).name.casefold()
      return not fb_check
      
    def exploder(hier_lv, inst):
      if forbbiden_check(inst):
        if hier_lv==0:
          inst.explode()
        else:
          for i in inst.cell.each_inst():
            exploder(hier_lv-1, i)
   
    def write(loc, inst):
      dbox = layout.cell(inst.cell_index).dbbox()
      text_param = {'text': str(loc.to_itype()), 'layer': text_layer_info, 'mag': 10*self.text_line_width}
      text_shapes = lay.create_cell("TEXT", "Basic", text_param).shapes(text_layer)
      text_dbox = lay.create_cell("TEXT", "Basic", text_param).dbbox()
      text_shapes.transform(pya.DTrans(loc.x + (dbox.p1.x+dbox.p2.x)/2 - (text_dbox.p2.x-text_dbox.p1.x)/2 + int(self.text_shift_x), loc.y + dbox.p2.y + int(self.text_shift_y)))
      for l_string in self.layers:
        l = self.layout.layer(int(l_string), 0)
        self.cell.shapes(l).insert(text_shapes)
        
    def writer(hier_lv, loc, inst):
      if forbbiden_check(inst):
        if hier_lv==0:
          write(loc, inst)
        else:
          if self.mark_less and inst.cell.hierarchy_levels()==0:
            write(loc, inst)
          for i in inst.cell.each_inst():
            writer(hier_lv-1, loc+i.dtrans.disp, i)
    
    
    layout = pya.CellView.active().layout().dup()
    lay = pya.Layout()
    text_layer = lay.layer(0, 0)
    text_layer_info = pya.LayerInfo(0, 0)
        
    search_dbox =pya.DBox(self.left_x,self.bot_y,self.right_x,self.top_y)   
     
    for hierarchy_level in self.hierarchy_levels: 
      hierarchy_level = int(hierarchy_level)
      
      if self.explode:
        for inst in layout.top_cell().each_overlapping_inst(search_dbox):
          for hier_lv in range(0, hierarchy_level+1):
            exploder(hier_lv, inst)
        
      for inst in layout.top_cell().each_overlapping_inst(search_dbox):
        writer(hierarchy_level, inst.dtrans.disp, inst)


           

    
  
</text>
</klayout-macro>
