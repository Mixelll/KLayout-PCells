<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya
import math

# PCell template
# This macro template provides the framework for a PCell library

# It is recommended to put PCell code into namespaces.
# TODO: change the module name

# The PCell declaration
# Each PCell must provide a declaration. It is recommended to use the PCell name as the class name.
# TODO: change the class name
class Circle_sized(pya.PCellDeclarationHelper):

  def __init__(self):

    # Important: initialize the super class
    super(Circle_sized, self).__init__()

    # declare the parameters
    # i.e. self.param("l", self.TypeLayer, "Layer", default = pya.LayerInfo(1, 0))
    #      self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    # declare the parameters
    self.param("layers", self.TypeList, "layers", default = [0])
    self.param("text_layers", self.TypeList, "Text layers", default = [0])
    self.param("d", self.TypeList, "diameters", default = 100)
    self.param("gap", self.TypeDouble, "gap", default = 100)
    self.param("center_line", self.TypeBoolean, "True for circle aligned at center, false for bottom", default = True)
    self.param("N", self.TypeInt, "N points circle", default = 1024)
    self.param("text_line_width", self.TypeDouble, "text_line_width", default = 5)
    self.param("text_gap", self.TypeDouble, "text_gap", default = 100)
    self.param("text_line", self.TypeBoolean, "Text in a single line", default = False)
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Circle Sized"
  
  def coerce_parameters_impl(self):
    pass
    # TODO: use x to access parameter x and set_x to modify it's value 
  def produce_impl(self):
  
    #from func import arc
    
    def arc(r, tet1, tet2, N):
      tet1 = 2*math.pi*tet1/360
      tet2 = 2*math.pi*tet2/360
      dtet = tet2 - tet1
      theta_range = range(N,-1,-1)
      out = list(theta_range)
      i = 0
      for tr in theta_range:
        ang = tet1 + tr*dtet/N
        out[i] = pya.DPoint(r*math.cos(ang), r*math.sin(ang))
        i = i+1  
      return out
    
    self.layout.dbu= 1e-6
    lay = pya.Layout()
    text_layer = lay.layer(0, 0)
    text_layer_info = pya.LayerInfo(0, 0)
    lr = len(self.d)
    start_x0 = float(self.d[0])/2
    
 
    start_x = start_x0
    for i in range(0,lr):
      r = float(self.d[i])/2
      for l_string in self.layers:
        l = self.layout.layer(int(l_string), 0)
        if self.center_line:
          self.cell.shapes(l).insert(DPolygon(arc(r, 0, 360, self.N)).transform(DTrans(start_x, 0.0)))
        else:
          self.cell.shapes(l).insert(DPolygon(arc(r, 0, 360, self.N)).transformed(DTrans(start_x, r)))
      start_x += r +(float(self.d[min(i+1,lr-1)])/2 + self.gap)
      
    dmax = 0
    for i in range(0,lr):
      d = float(self.d[i])
      dmax = max(dmax,d)
    start_x = start_x0
    for i in range(0,lr):
      d = float(self.d[i])
      r = d/2
      text_param = {'text': "D="+self.d[i], 'layer': text_layer_info, 'mag': 1e4*self.text_line_width}
      text_shapes = lay.create_cell("TEXT", "Basic", text_param).shapes(text_layer).dup()
      if self.text_line:
        text_shapes.transform(Trans(int(1e6*(start_x-start_x0)), int(1e6*(dmax+self.text_gap))))
      else:
        text_shapes.transform(Trans(int(1e6*(start_x-start_x0)), int(1e6*(d+self.text_gap))))
      for l_string in self.text_layers:
        l = self.layout.layer(int(l_string), 0)
        self.cell.shapes(l).insert(text_shapes)
      start_x += r +(float(self.d[min(i+1,lr-1)])/2 + self.gap)
</text>
</klayout-macro>
