<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description/>
 <version/>
 <category>pymacros</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>true</autorun>
 <autorun-early>false</autorun-early>
 <shortcut/>
 <show-in-menu>false</show-in-menu>
 <group-name/>
 <menu-path/>
 <interpreter>python</interpreter>
 <dsl-interpreter-name/>
 <text>import pya

# PCell template
# This macro template provides the framework for a PCell library

# It is recommended to put PCell code into namespaces.
# TODO: change the module name

# The PCell declaration
# Each PCell must provide a declaration. It is recommended to use the PCell name as the class name.
# TODO: change the class name
class Graphene_Schottky_4(pya.PCellDeclarationHelper):

  def __init__(self):

    # Important: initialize the super class
    super(Graphene_Schottky_4, self).__init__()

    # declare the parameters
    # i.e. self.param("l", self.TypeLayer, "Layer", default = pya.LayerInfo(1, 0))
    #      self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    # declare the parameters
    self.param("lo", self.TypeLayer, "Layer", default = pya.LayerInfo(0, 0))
    self.param("lm1", self.TypeLayer, "Layer", default = pya.LayerInfo(1, 0))
    self.param("lg", self.TypeLayer, "Layer", default = pya.LayerInfo(2, 0))
    self.param("lm2", self.TypeLayer, "Layer", default = pya.LayerInfo(3, 0))
    self.param("s", self.TypeShape, "", default = pya.DPoint(0, 0))
    self.param("N_points_polygon", self.TypeInt, "N_points_polygon", default = 1024)
    self.param("N_Si_Contacts", self.TypeInt, "N_Si_Contacts", default = 1)
    self.param("N_Graphene_Contacts", self.TypeInt, "N_Graphene_Contacts", default = 1)
    self.param("Si_contacts_short", self.TypeInt, "Si_contacts_short", default = 1)
    self.param("ox_inner", self.TypeDouble, "ox_inner", default = 100000)  
    self.param("oxgap", self.TypeDouble, "oxgap", default = 10000) 
    self.param("ox_outer_x", self.TypeDouble, "ox_outer_x", default = 50000) 
    self.param("ox_outer_y", self.TypeDouble, "ox_outer_y", default = 100000)  
    self.param("ox_ang_1", self.TypeDouble, "ox_ang_1", default = 30) 
    self.param("ox_ang_2", self.TypeDouble, "ox_ang_2", default = 150)  
    self.param("m1_ox_diff_outer_x", self.TypeDouble, "m1_ox_diff_outer_x", default = 5000)   
    self.param("m1_ox_diff_outer_y", self.TypeDouble, "m1_ox_diff_outer_y", default = 5000) 
    self.param("m1_ox_diff_radial", self.TypeDouble, "m1_ox_diff_radial", default = 5000)
    self.param("m1_ox_diff_angle", self.TypeDouble, "m1_ox_diff_angle", default = 1)  
    self.param("gr_in_r", self.TypeDouble, "gr_in_r", default = 95000) 
    self.param("gr_out_r", self.TypeDouble, "gr_out_r", default = 110000) 
    self.param("gr_in_ang_1", self.TypeDouble, "gr_in_ang_1", default = -20) 
    self.param("gr_in_ang_2", self.TypeDouble, "gr_in_ang_2", default = 20) 
    self.param("gr_out_ang_1", self.TypeDouble, "gr_out_ang_1", default = -20) 
    self.param("gr_out_ang_2", self.TypeDouble, "gr_out_ang_2", default = 20) 
    self.param("m1_radial_gr_diff", self.TypeDouble, "m1_radial_gr_diff", default = 5000) 
    self.param("m1_short_from_m1_edge_x", self.TypeDouble, "m1_short_from_m1_edge_x", default = 100000)
    self.param("m1_short_width", self.TypeDouble, "m1_short_width", default = 30000)  
    self.param("m2_ang_1", self.TypeDouble, "m2_ang_1", default = -25) 
    self.param("m2_ang_2", self.TypeDouble, "m2_ang_2", default = 25)  
    self.param("m2_outer_x", self.TypeDouble, "m2_outer_x", default = 50000)
    self.param("m2_top_beyond_rect_shift_y", self.TypeDouble, "m2_top_beyond_rect_shift_y", default = 0)
    self.param("m2_bot_beyond_rect_shift_y", self.TypeDouble, "m2_bot_beyond_rect_shift_y", default = 0)
    self.param("m1_m2_separation", self.TypeDouble, "m1_m2_separation", default = 10000)
    self.param("gr_etch_from_m_edge", self.TypeDouble, "gr_etch_from_m_edge", default = 30000)
    self.param("dier_right_x", self.TypeDouble, "dier_right_x", default = 30000)
    self.param("dier_left_x", self.TypeDouble, "dier_left_x", default = 30000)      
    self.param("dier_top_y", self.TypeDouble, "dier_top_y", default = 30000)
    self.param("dier_bot_y", self.TypeDouble, "dier_bot_y", default = 30000)   
    
  def display_text_impl(self):
    # Provide a descriptive text for the cell
    return "Graphene Schottky 4"
  
  def coerce_parameters_impl(self):
    pass
    # TODO: use x to access parameter x and set_x to modify it's value 
  def produce_impl(self):
    # TODO: produce the cell content 
    # i.e. self.cell().shapes(self.l_layer).insert(pya.Polygon(...))
    self.dpath =  "C:/Users/sz1x3/Google Drive/EE MSc/KLayout/"
    
    
    #ox_metal_equal = 1
    
  #  self.ox_inner = 100000
  #  self.oxgap = 10000
  #  self.ox_outer_x = 50000
  #  self.ox_outer_y = 100000
 #   self.ox_ang_1 = 0
 #   self.ox_ang_2 = 180
    
  #  self.m1_ox_diff_outer_x = 0
   # self.m1_ox_diff_outer_y = 0
    
   # self.m1_ox_diff_radial = 0
    
    
      
    ox_gap_tot = self.ox_inner + self.oxgap
    ox_outer_tot_x = ox_gap_tot + self.ox_outer_x
    ox_outer_tot_y = ox_gap_tot + self.ox_outer_y
    
    m1_rad = ox_gap_tot - self.m1_ox_diff_radial
    m1_outer_tot_x = ox_outer_tot_x + self.m1_ox_diff_outer_x
    m1_outer_tot_y = ox_outer_tot_y + self.m1_ox_diff_outer_y
    
    m1_angle_1 = self.ox_ang_1 - self.m1_ox_diff_angle
    m1_angle_2 = self.ox_ang_2 + self.m1_ox_diff_angle
    
   # self.gr_in_r = 110000
  #  self.gr_out_r = 110000
  #  self.gr_ang_1 = -40
   # self.gr_ang_2 = -6
    
   # self.m2_in_r = 105000
   # self.m2_ang_1 = -41
   # self.m2_ang_2 = -5
    

      
    layout = pya.Layout()
    top = layout.create_cell("TOP")
    
#    lo = layout.layer(1, 0, "oxide opening")
#    lm1 = layout.layer(2, 0, "m1")
#    lg = layout.layer(3, 0, "graphene RIE")
#    lm2 = layout.layer(4, 0, "m2")
    
    def arc(r, hullorhole, tet1, tet2, N):
      tet1 = 2*math.pi*tet1/360
      tet2 = 2*math.pi*tet2/360
      dtet = tet2 - tet1
      
      if hullorhole:
         theta_range = range(N,-1,-1)
      else:
         theta_range = range(0, N+1)
        
      out = list(theta_range)
      i = 0
      for tr in theta_range:
        ang = tet1 + tr*dtet/N
        out[i] = pya.Point(r*math.cos(ang), r*math.sin(ang))
        i = i+1  
      return out
    
        
    def don(r_in, r_ou, tet1, tet2, N):
      tet1 = 2*math.pi*tet1/360
      tet2 = 2*math.pi*tet2/360
      dtet = tet2 - tet1
    
      theta_range = range(N, -1,-1)
      out = 2*list(theta_range)
      i = 0
      for tr in theta_range:
        ang = tet1 + tr*dtet/N
        out[i] = pya.Point(r_ou*math.cos(ang), r_ou*math.sin(ang))
        out[2*N +1 -i] = pya.Point(r_in*math.cos(ang), r_in*math.sin(ang))
        i = i+1
          
      return out
    
    
    
    m2_outer_tot_x = self.m2_outer_x + self.gr_out_r
    m2_outer_tot_y = m1_outer_tot_y
    
    
    # #M2 (Grtaphene contact)
    #right

    m2_right_arc_points = arc(self.gr_out_r -self.m1_radial_gr_diff, 0,self.m2_ang_1, self.m2_ang_2, self.N_points_polygon)
    m2_right_rect_clockwise = [pya.Point(m2_outer_tot_x, m2_right_arc_points[self.N_points_polygon].y + self.m2_top_beyond_rect_shift_y), pya.Point(m2_outer_tot_x, m2_right_arc_points[0].y - self.m2_bot_beyond_rect_shift_y)]
    

    #left
    #m2_left_arc_points = arc(self.m2_in_r, 0, 180 -self.m2_ang_2, 180 -self.m2_ang_1, self.N_points_polygon)
    m2_left_arc_points = arc(self.gr_out_r -self.m1_radial_gr_diff, 0, 180 -self.m2_ang_2, 180 -self.m2_ang_1, self.N_points_polygon)
    m2_left_rect_clockwise = [pya.Point(-m2_outer_tot_x, m2_left_arc_points[self.N_points_polygon].y - self.m2_bot_beyond_rect_shift_y), pya.Point(-m2_outer_tot_x, m2_left_arc_points[0].y + self.m2_top_beyond_rect_shift_y)]
    
    if self.N_Graphene_Contacts==1:
      m2_contact_single = m2_right_rect_clockwise
      m2_contact_single.extend(m2_left_rect_clockwise)
      m2_contact_single.extend(m2_right_arc_points)
      self.cell.shapes(self.lm2_layer).insert(pya.Polygon(m2_contact_single, False))
      
    if self.N_Graphene_Contacts&gt;1:
      m2_right_rect_clockwise.extend(m2_right_arc_points)
      m2_left_rect_clockwise.extend(m2_left_arc_points)
      self.cell.shapes(self.lm2_layer).insert(pya.Polygon(m2_right_rect_clockwise, False))
      self.cell.shapes(self.lm2_layer).insert(pya.Polygon(m2_left_rect_clockwise, False))
    
    
        # #Oxide etch
    #inner
    self.cell.shapes(self.lo_layer).insert(pya.Polygon(arc(self.ox_inner, 1,0, 360, self.N_points_polygon) ,False))
    #outer
    #-top
    if self.N_Si_Contacts:
      ox_top_arc_points = arc(ox_gap_tot, 0,self.ox_ang_1, self.ox_ang_2, self.N_points_polygon)
      ox_top_right_rect_y = max(ox_top_arc_points[0].y, m2_right_arc_points[self.N_points_polygon].y + self.m2_top_beyond_rect_shift_y + self.m1_m2_separation + self.m1_ox_diff_radial)
      ox_top_left_rect_y = max(ox_top_arc_points[self.N_points_polygon].y, m2_left_arc_points[0].y + self.m2_top_beyond_rect_shift_y + self.m1_m2_separation + self.m1_ox_diff_radial)
      ox_top_rect_clockwise = [pya.Point(-ox_outer_tot_x, ox_top_left_rect_y), pya.Point(-ox_outer_tot_x, ox_outer_tot_y), pya.Point(ox_outer_tot_x, ox_outer_tot_y), pya.Point(ox_outer_tot_x, ox_top_right_rect_y)]
      ox_top_rect_clockwise.extend(ox_top_arc_points)
      self.cell.shapes(self.lo_layer).insert(pya.Polygon(ox_top_rect_clockwise))
    #-bot
    if self.N_Si_Contacts&gt;1:
      ox_bot_arc_points = arc(ox_gap_tot, 0, 360 -self.ox_ang_2, 360 -self.ox_ang_1, self.N_points_polygon)
      ox_bot_right_rect_y = min(ox_bot_arc_points[self.N_points_polygon].y, m2_right_arc_points[0].y - self.m2_bot_beyond_rect_shift_y - self.m1_m2_separation - self.m1_ox_diff_radial)
      ox_bot_left_rect_y = min(ox_bot_arc_points[0].y, m2_left_arc_points[self.N_points_polygon].y - self.m2_bot_beyond_rect_shift_y - self.m1_m2_separation - self.m1_ox_diff_radial)
      ox_bot_rect_counterclockwise = [pya.Point(-ox_outer_tot_x, ox_bot_left_rect_y), pya.Point(-ox_outer_tot_x, -ox_outer_tot_y), pya.Point(ox_outer_tot_x, -ox_outer_tot_y), pya.Point(ox_outer_tot_x, ox_bot_right_rect_y)]
      ox_bot_rect_counterclockwise.reverse()
      ox_bot_rect_counterclockwise.extend(ox_bot_arc_points)
      self.cell.shapes(self.lo_layer).insert(pya.Polygon(ox_bot_rect_counterclockwise))
    
    
    # #M1 (Si contact)
    #top
    if self.N_Si_Contacts:
      m1_top_arc_points = arc(m1_rad, 0, m1_angle_1, m1_angle_2, self.N_points_polygon)
      m1_top_right_rect_y = max(m1_top_arc_points[0].y, m2_right_arc_points[self.N_points_polygon].y + self.m2_top_beyond_rect_shift_y + self.m1_m2_separation)
      m1_top_left_rect_y = max(m1_top_arc_points[self.N_points_polygon].y, m2_left_arc_points[0].y + self.m2_top_beyond_rect_shift_y + self.m1_m2_separation)
      m1_top_rect_clockwise = [pya.Point(-m1_outer_tot_x, m1_top_left_rect_y), pya.Point(-m1_outer_tot_x, m1_outer_tot_y), pya.Point(m1_outer_tot_x, m1_outer_tot_y), pya.Point(m1_outer_tot_x, m1_top_right_rect_y)]
      m1_top_rect_clockwise.extend(m1_top_arc_points)
      self.cell.shapes(self.lm1_layer).insert(pya.Polygon(m1_top_rect_clockwise))
    #bot
    if self.N_Si_Contacts&gt;1:
      m1_bot_arc_points = arc(m1_rad, 0, 360 -m1_angle_2, 360 -m1_angle_1, self.N_points_polygon)
      m1_bot_right_rect_y = min(m1_bot_arc_points[0].y, m2_right_arc_points[0].y - self.m2_bot_beyond_rect_shift_y - self.m1_m2_separation)
      m1_bot_left_rect_y = min(m1_bot_arc_points[self.N_points_polygon].y, m2_left_arc_points[self.N_points_polygon].y - self.m2_bot_beyond_rect_shift_y - self.m1_m2_separation)
      m1_top_rect_counterclockwise = [pya.Point(-m1_outer_tot_x, m1_bot_left_rect_y), pya.Point(-m1_outer_tot_x, -m1_outer_tot_y), pya.Point(m1_outer_tot_x, -m1_outer_tot_y), pya.Point(m1_outer_tot_x, m1_bot_right_rect_y)]
      m1_top_rect_counterclockwise.reverse()
      m1_top_rect_counterclockwise.extend(m1_bot_arc_points)
      self.cell.shapes(self.lm1_layer).insert(pya.Polygon(m1_top_rect_counterclockwise))
    #short
    if self.Si_contacts_short:
#      m1_short_polygon = pya.Polygon([pya.Point(-m1_outer_tot_x, -m1_outer_tot_y), pya.Point(-m1_outer_tot_x -self.m1_short_from_m1_edge_x, -m1_outer_tot_y), pya.Point(-m1_outer_tot_x -self.m1_short_from_m1_edge_x, m1_outer_tot_y), pya.Point(-m1_outer_tot_x, m1_outer_tot_y)])
#      m1_short_polygon.insert_hole([pya.Point(-m1_outer_tot_x, m1_outer_tot_y -self.m1_short_width), pya.Point(-m1_outer_tot_x -self.m1_short_from_m1_edge_x +self.m1_short_width, m1_outer_tot_y -self.m1_short_width), pya.Point(-m1_outer_tot_x -self.m1_short_from_m1_edge_x +self.m1_short_width, -m1_outer_tot_y +self.m1_short_width), pya.Point(-m1_outer_tot_x, -m1_outer_tot_y +self.m1_short_width)])
      m1_short_polygon = pya.Polygon([pya.Point(-m1_outer_tot_x, -m1_outer_tot_y), pya.Point(-m1_outer_tot_x -self.m1_short_from_m1_edge_x, -m1_outer_tot_y), pya.Point(-m1_outer_tot_x -self.m1_short_from_m1_edge_x, m1_outer_tot_y), pya.Point(-m1_outer_tot_x, m1_outer_tot_y), pya.Point(-m1_outer_tot_x, m1_outer_tot_y -self.m1_short_width), pya.Point(-m1_outer_tot_x -self.m1_short_from_m1_edge_x +self.m1_short_width, m1_outer_tot_y -self.m1_short_width), pya.Point(-m1_outer_tot_x -self.m1_short_from_m1_edge_x +self.m1_short_width, -m1_outer_tot_y +self.m1_short_width), pya.Point(-m1_outer_tot_x, -m1_outer_tot_y +self.m1_short_width)], False)
      self.cell.shapes(self.lm1_layer).insert(m1_short_polygon)
      
      
      

    dier_right_x = max(m1_outer_tot_x, m2_outer_tot_x) + self.gr_etch_from_m_edge
    if self.Si_contacts_short:
      dier_left_x = max(m1_outer_tot_x +self.m1_short_from_m1_edge_x, m2_outer_tot_x) + self.gr_etch_from_m_edge
    else:
      dier_left_x = dier_right_x
    dier_top_y = max(m1_outer_tot_y, m2_outer_tot_y) + self.gr_etch_from_m_edge
    dier_bot_y = max(abs(m2_right_rect_clockwise[1].y), m2_outer_tot_y) + self.gr_etch_from_m_edge
    
    if self.dier_right_x&lt;dier_right_x:
      self.dier_right_x = dier_right_x
    if self.dier_left_x&lt;dier_left_x:
      self.dier_left_x = dier_left_x
    if self.dier_top_y&lt;dier_top_y:
      self.dier_top_y = dier_top_y
    if self.dier_bot_y&lt;dier_bot_y:
      self.dier_bot_y = dier_bot_y
      
      
      
      
        # #Graphene pattern
    #die size
    die_hull = pya.Polygon([pya.Point(-self.dier_left_x, -self.dier_bot_y) , pya.Point(-self.dier_left_x, self.dier_top_y), pya.Point(self.dier_right_x, self.dier_top_y), pya.Point(self.dier_right_x, -self.dier_bot_y)], False)
    #graphene shape

    if self.N_Graphene_Contacts&gt;1:
      gr_hole = arc(self.gr_out_r, 0, self.gr_out_ang_1, self.gr_out_ang_2, self.N_points_polygon)
      gr_hole.extend(arc(self.gr_in_r, 0, self.gr_in_ang_2, 180 - self.gr_in_ang_2, self.N_points_polygon))
      gr_hole.extend(arc(self.gr_out_r, 0 , 180 - self.gr_out_ang_2, 180 - self.gr_out_ang_1, self.N_points_polygon))
      gr_hole.extend(arc(self.gr_in_r, 0, 180 - self.gr_in_ang_1, self.gr_in_ang_1+360, self.N_points_polygon))
    else:
      gr_hole = arc(self.gr_out_r, 0, self.gr_out_ang_1, self.gr_out_ang_2, self.N_points_polygon)
      gr_hole.extend(arc(self.gr_in_r, 0, self.gr_in_ang_2, 360 + self.gr_in_ang_1, self.N_points_polygon))

    die_hull.insert_hole(gr_hole, False)
    self.cell.shapes(self.lg_layer).insert(die_hull)
      

# layout.write(self.dpath + "device_3a.gds")


  # optional:
  # def can_create_from_shape_impl(self):
  #   TODO: determine if we have a shape that we can use to derive the 
  #   PCell parameters from and return true in that case
  # 
  # optional:
  # def parameters_from_shape_impl(self):
  #   TODO: change parameters using set_x to reflect the parameter for the
  #   given shape
  # 
  # optional:
  # def transformation_from_shape_impl(self):
  #   TODO: return a RBA::Trans object for the initial transformation of
  #   the instance
  
# TODO: add more PCell classes ..

# The PCell library declaration
# A PCell library must be declared by deriving a custom class from RBA::Library.
# The main purpose of this class is to provide the PCell declarations and to register itself
# with a proper name.
# TODO: change the class name
#class PCellLib(pya.Library):

  #def __init__(self):
  
    # TODO: change the description
    #self.description = "My PCell library"
    
    # register the PCell declarations
    # TODO: change the names
#PCellLib().layout().register_pcell("Graphene_Schottky_4", Graphene_Schottky_4())
    # TODO: register more PCell declarations
    
    # register our library with the name "PCellLib"
    # TODO: change the library name
    #self.register("PCellLib")
    
# instantiate and register the library
# TODO: change the library name
#PCellLib()

</text>
</klayout-macro>
